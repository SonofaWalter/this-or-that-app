{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useState, useEffect, useCallback } from 'react';\n\n// Main App component\nconst App = () => {\n  _s();\n  // ... (rest of your state declarations) ...\n\n  /**\n   * Fetches two \"This or That\" options from the Gemini API based on the given category.\n   * This function is responsible only for the API call and returning the raw options.\n   * @param {string} category - The category to generate options for.\n   * @returns {Promise<string[]>} - A promise that resolves to an array of two strings [option1, option2].\n   */\n  const fetchOptionsFromAI = useCallback(async category => {\n    setError('');\n    try {\n      // TEMPORARY: LOGGING API KEY FOR DIAGNOSIS IN NETLIFY BUILD LOGS\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY;\n      console.log('--- Netlify Build Log Check: API Key Value ---', apiKey); // This line is new\n      // --- END TEMPORARY LOGGING ---\n\n      if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set REACT_APP_GEMINI_API_KEY in Netlify environment variables.\");\n      }\n\n      // ... (rest of your prompt and payload definition) ...\n\n      const prompt = `Generate two distinct, highly creative, engaging, and **completely unique** \"This or That\" options for the category \"${category}\".\n      **Crucially, ensure that the two options use different primary keywords and concepts to avoid any repetition or similarity in wording, even if subtle.**\n      The options should be short phrases and present a clear dilemma.\n      \n      Example for \"Food & Drink\":\n      - \"Eat only bland food for life\"\n      - \"Eat only extremely spicy food for life\"\n      \n      Example for \"Superpowers\":\n      - \"Ability to fly anywhere instantly\"\n      - \"Ability to control minds but only while sleeping\"\n\n      Provide the response in a JSON array format with two strings, like:\n      [\"Option 1 Text\", \"Option 2 Text\"]`;\n      let chatHistory = [];\n      chatHistory.push({\n        role: \"user\",\n        parts: [{\n          text: prompt\n        }]\n      });\n      const payload = {\n        contents: chatHistory,\n        generationConfig: {\n          responseMimeType: \"application/json\",\n          responseSchema: {\n            type: \"ARRAY\",\n            items: {\n              type: \"STRING\"\n            },\n            minItems: 2,\n            maxItems: 2\n          },\n          temperature: 1.0\n        }\n      };\n      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;\n      const response = await fetch(apiUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n      });\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(`HTTP error! Status: ${response.status}. Details: ${JSON.stringify(errorData)}`);\n      }\n      const result = await response.json();\n      if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {\n        const jsonString = result.candidates[0].content.parts[0].text;\n        const options = JSON.parse(jsonString);\n        if (Array.isArray(options) && options.length === 2 && typeof options[0] === 'string' && typeof options[1] === 'string') {\n          return options;\n        } else {\n          throw new Error('AI response format was unexpected. Expected an array of two strings.');\n        }\n      } else {\n        throw new Error('Failed to generate options from AI. Response was empty or malformed.');\n      }\n    } catch (err) {\n      console.error(\"Error fetching options:\", err);\n      setError(`Failed to fetch options: ${err.message}. Please check your network or API key configuration.`);\n      return ['', ''];\n    }\n  }, []);\n\n  // ... (rest of your App component) ...\n};\n_s(App, \"iFzjMI8v53KtY3oVU49skR3Lfuc=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","useCallback","App","_s","fetchOptionsFromAI","category","setError","apiKey","process","env","REACT_APP_GEMINI_API_KEY","console","log","Error","prompt","chatHistory","push","role","parts","text","payload","contents","generationConfig","responseMimeType","responseSchema","type","items","minItems","maxItems","temperature","apiUrl","response","fetch","method","headers","body","JSON","stringify","ok","errorData","json","status","result","candidates","length","content","jsonString","options","parse","Array","isArray","err","error","message","_c","$RefreshReg$"],"sources":["/Users/tripochenski/Documents/Projects/this-or-that-app/src/App.js"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\n\n// Main App component\nconst App = () => {\n  // ... (rest of your state declarations) ...\n\n  /**\n   * Fetches two \"This or That\" options from the Gemini API based on the given category.\n   * This function is responsible only for the API call and returning the raw options.\n   * @param {string} category - The category to generate options for.\n   * @returns {Promise<string[]>} - A promise that resolves to an array of two strings [option1, option2].\n   */\n  const fetchOptionsFromAI = useCallback(async (category) => {\n    setError('');\n    try {\n      // TEMPORARY: LOGGING API KEY FOR DIAGNOSIS IN NETLIFY BUILD LOGS\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY; \n      console.log('--- Netlify Build Log Check: API Key Value ---', apiKey); // This line is new\n      // --- END TEMPORARY LOGGING ---\n\n      if (!apiKey) {\n        throw new Error(\"GEMINI_API_KEY is not configured. Please set REACT_APP_GEMINI_API_KEY in Netlify environment variables.\");\n      }\n\n      // ... (rest of your prompt and payload definition) ...\n\n      const prompt = `Generate two distinct, highly creative, engaging, and **completely unique** \"This or That\" options for the category \"${category}\".\n      **Crucially, ensure that the two options use different primary keywords and concepts to avoid any repetition or similarity in wording, even if subtle.**\n      The options should be short phrases and present a clear dilemma.\n      \n      Example for \"Food & Drink\":\n      - \"Eat only bland food for life\"\n      - \"Eat only extremely spicy food for life\"\n      \n      Example for \"Superpowers\":\n      - \"Ability to fly anywhere instantly\"\n      - \"Ability to control minds but only while sleeping\"\n\n      Provide the response in a JSON array format with two strings, like:\n      [\"Option 1 Text\", \"Option 2 Text\"]`;\n\n      let chatHistory = [];\n      chatHistory.push({ role: \"user\", parts: [{ text: prompt }] });\n\n      const payload = {\n        contents: chatHistory,\n        generationConfig: {\n          responseMimeType: \"application/json\",\n          responseSchema: {\n            type: \"ARRAY\",\n            items: {\n              type: \"STRING\"\n            },\n            minItems: 2,\n            maxItems: 2\n          },\n          temperature: 1.0,\n        }\n      };\n\n      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;\n\n      const response = await fetch(apiUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload)\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(`HTTP error! Status: ${response.status}. Details: ${JSON.stringify(errorData)}`);\n      }\n\n      const result = await response.json();\n\n      if (\n        result.candidates &&\n        result.candidates.length > 0 &&\n        result.candidates[0].content &&\n        result.candidates[0].content.parts &&\n        result.candidates[0].content.parts.length > 0\n      ) {\n        const jsonString = result.candidates[0].content.parts[0].text;\n        const options = JSON.parse(jsonString);\n\n        if (Array.isArray(options) && options.length === 2 &&\n            typeof options[0] === 'string' && typeof options[1] === 'string') {\n          return options;\n        } else {\n          throw new Error('AI response format was unexpected. Expected an array of two strings.');\n        }\n      } else {\n        throw new Error('Failed to generate options from AI. Response was empty or malformed.');\n      }\n    } catch (err) {\n      console.error(\"Error fetching options:\", err);\n      setError(`Failed to fetch options: ${err.message}. Please check your network or API key configuration.`);\n      return ['', ''];\n    }\n  }, []);\n\n  // ... (rest of your App component) ...\n};\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}